The Bitcoin system operates on a foundation of transactions, which are compiled into blocks. Approximately every 10 minutes, a new block is formed, encapsulating the latest transactions submitted to the network. This timing creates a balancing act between achieving consensus on the network's transactions and the speed at which these transactions are confirmed when included in a block.
Consider if blocks were generated only once every 24 hours. It would significantly simplify the process for all nodes in the network to reach an agreement on the sequence of these blocks. However, this would also mean that users would have to endure a lengthy wait to receive confirmation that their transactions have been validated and are secure.
Now, who takes on the task of creating these blocks? If a particular node were designated for this role, it could choose which pending transactions to include in the block before broadcasting it to the rest of the network. However, this approach reintroduces the issue of centralization, creating a single point of vulnerability susceptible to failure, coercion, and corruption.
The ingenious solution lies in decentralization: allowing any node on the network the opportunity to create blocks and disseminate them across the network. But this raises another crucial question: If every node can create blocks, how do we ensure that only one block is produced every 10 minutes?
One could imagine a system where a random node is selected to create the next block. Yet, this leads to further queries: Who administers this selection process? How can we ensure that this selection is genuinely random and fair?
Satoshi Nakamoto introduced an elegant solution to this conundrum. Since any node can create a block, to qualify for creating the next block, nodes engage in a form of competition. This contest is structured so that each participant has an equal chance of success, with the winning node able to provide verifiable proof of their victory. This proof enables other nodes in the network to validate and reach a consensus without the need for a central authority.
The reward for the node that triumphs in this competition? The privilege of creating the next block on the network!
This competition is known as "proof of work," and it's a cornerstone of how the Bitcoin network achieves a decentralized, global consensus. Through this process, Bitcoin maintains its integrity and trustworthiness, ensuring that no single entity can control or manipulate the transaction ledger.
Let us understand how a node can participate in this competition and create the next block.
Remember that in the Bitcoin network after validating transactions, nodes will add them to the memory pool, also known as the transaction pool. This is where transactions wait until they can be included in a new block.
A miner node operates like any other node in terms of collecting, validating, and relaying transactions. However, it also plays a unique role in forming these transactions into a candidate block.
To illustrate this, let's consider a miner node's activity during a typical transaction process, such as a retail purchase. The transaction from this purchase is included in a newly mined block. For our example, we'll assume that the miner node is responsible for mining this particular block.
The miner node maintains a local copy of the blockchain and constantly updates it with new blocks mined by other nodes. While it is mining the actual block, it also listens for transactions to include in the next block. Simultaneously, it listens for new blocks discovered by other nodes. When the miner node receives the latest block, it signifies the end of the competition for the last block and the start of the new competition for the actual block.
During the time it took to mine the last block, the miner node was collecting transactions in preparation for the next block. These transactions accumulate in the memory pool. After validating the latest received block, the miner node compares it against all transactions in the memory pool. Any transaction already included in the last block is removed from the pool. The remaining transactions in the memory pool are unconfirmed, awaiting inclusion in a new block.
The miner node immediately starts constructing a new, empty candidate block for the next block number. This block is termed a 'candidate' because it is not yet a valid block—it lacks a valid Proof-of-Work. It only becomes a valid block if the miner node successfully finds a solution to the Proof-of-Work algorithm (we will see soon how this is done).
As the miner node incorporates transactions from the memory pool into the new candidate block, the block begins to take shape with various transactions and their associated transaction fees.
The process of selecting transactions for the next block by a mining node is a strategic one, primarily driven by transaction size and fees. Each transaction within the network has two key attributes: its size, measured in bytes, and the transaction fee, which is the amount the sender is willing to pay to have the transaction included in a block (as we saw in the transaction chapter).
When a mining node prepares to create a new block, it faces the challenge of maximizing its potential reward while adhering to the block size limit set by the Bitcoin protocol. The block size limit is a cap on the amount of data each block can contain, ensuring that blocks are not too large to be quickly propagated through the network.
Given these constraints, the mining node adopts a strategy of selecting transactions that strike a balance between the fees they offer and the space they occupy in the block. Typically, transactions with higher fees are more attractive to miners because they represent a greater reward for the work done to mine the block. Therefore, a miner will often prioritize transactions with higher fees per byte.
The node assesses the available transactions in the memory pool, comparing their sizes and fees. The goal is to include as many high-fee transactions as possible, optimizing the use of the block's capacity to maximize the total fees collected. This is akin to a puzzle where the miner must fit various-sized pieces (transactions) into a set space (the block) in a way that maximizes the value (fees).
However, this doesn't mean that only high-fee transactions are selected. Depending on the transaction landscape at the time, a miner might also include smaller or lower-fee transactions to fully utilize the block's capacity, especially if there are not enough high-fee transactions to fill the block.
This selection process is crucial as it affects not only the miner's rewards but also the speed at which transactions are confirmed on the network. Transactions with higher fees tend to be confirmed more quickly, as they are more likely to be picked up by miners, while those with lower fees may have to wait longer.
In summary, a mining node selects transactions for the next block based on careful consideration of transaction size and fees, aiming to maximize the fees collected within the constraints of the block size limit.
Given the effort, energy, and resources required to operate as a mining node in the Bitcoin network, one might wonder what incentivizes nodes to undertake this role. 
The answer lies in the rewards that mining nodes receive for their critical contribution to the network's functioning.
In addition to the transaction fees collected from users for including their transactions in a block, mining nodes are also rewarded with a special type of transaction known as a "coinbase transaction".
This coinbase transaction is unique and serves as the primary incentive for nodes to participate in the mining process.
When a mining node successfully creates a new block, it includes the coinbase transaction at the beginning of this block. This transaction is unique in that it creates new bitcoins, which are awarded to the miner. The number of bitcoins awarded in the coinbase transaction is predetermined by the Bitcoin protocol and is adjusted over time through an event known as "halving" (we will understand better later). This reward serves as compensation for the miner's expenditure of computational power and energy in solving the problem required to find a valid Proof-of-Work for the new block.
The combination of transaction fees and the coinbase reward constitutes the total reward for a miner. This dual-reward system compensates miners for the resources expended in maintaining and securing the network.
The coinbase transaction differs fundamentally from regular transactions. Unlike standard transactions, which consume Unspent Transaction Outputs (UTXOs) as inputs, the coinbase transaction has only one input, known as the "coinbase." This unique input effectively creates Bitcoin out of nothing. Additionally, the coinbase transaction typically has one output, which is the payment to the miner's own Bitcoin address.
Now that the mining node has carefully selected which transactions will be included in the next block and indicated its reward through the coinbase transaction, the next crucial step is to construct the block header.
It serves as a sort of digital fingerprint for the block, encapsulating key information in a compact and secure format. The header includes several vital pieces of data:
Version Number: Indicates the version of the Bitcoin protocol being used.
Previous Block Hash: A reference to the hash of the immediately preceding block in the blockchain, linking the new block to the existing chain in a chronological and immutable sequence.
Merkle Root: A unique identifier derived from the hashes of all transactions included in the block, including the coinbase transaction. This ensures the integrity and immutability of the transactions within the block.
Timestamp: Records the time when the block was created.
Difficulty Target: A representation of the current difficulty level for mining new blocks, which adjusts over time to maintain the average time between blocks.
Nonce: A variable number that miners change during the mining process to try and achieve a hash below the difficulty target.
To facilitate understanding, in the following example, we will only use the fields: Previous Block Hash, Merkle Root, and Nonce.
Merkle Root:
As we have already seen, this process involves summarizing all the transactions in the block using a structure known as a Merkle tree. This is done to incorporate the Merkle root into the block header, which serves as a comprehensive yet efficient summary of all the transactions in the block.
The Merkle tree starts with the coinbase transaction, which is always the first transaction in the block. Following this, all other transactions that the miner has selected for inclusion in the block are added. To construct a Merkle tree, there must be an even number of leaf nodes. If the number of transactions is odd, the last transaction is duplicated to create an even number of leaf nodes.
Each leaf node in the Merkle tree is a hash of a single transaction. These transaction hashes are then paired and hashed together, which forms the next level of the tree. This process of pairing and hashing continues upwards through the tree, with each level being a hash of its predecessor, until only one hash remains. This final hash is the Merkle root, a single, compact 32-byte value that uniquely represents all the transactions in the block.
The Merkle root is then added to the block header. It acts as an efficient and secure way to verify the presence and integrity of any transaction within the block. By using a Merkle tree, it is possible to check whether a specific transaction is included in a block without needing to hold the entire list of transactions.
Nonce:
In the Hash Chapter, we talked about an important concept: the 'nonce.' A nonce is essentially a random number that serves as a variable input in the hash function used in block creation. The unique property of a nonce is that even a minor change in its value can result in a drastically different output from the hash function. This characteristic is fundamental to the mining process.
For each block header, the mining node selects a nonce and inputs it into the hash function along with the other components of the header. The output of this function, or the hash, is then evaluated against the network's current Difficulty Target.
The primary objective in mining is to find a nonce that, when used in the hash function, produces an output (block hash) that meets the Difficulty Target. This target defines the required conditions for a valid block hash, usually a hash that starts with a certain number of zeros. Since the output of the hash function is unpredictable, the only way to achieve this is through trial and error, by trying a vast number of different nonce values. This process is known as 'proof of work' and it requires substantial computational effort.
When a miner finally discovers a nonce that produces a hash meeting the Difficulty Target, it means they have successfully mined a block. This nonce is then included in the block header, and the new block is broadcast to the rest of the network for verification and addition to the blockchain. The discovery of the correct nonce, thus, is the pivotal moment in the mining process, enabling the creation of a new block and the reward that comes with it.
Let's simulate an example with these variables to illustrate how a mining node operates during the mining process:
Previous Block Hash: Suppose the hash of the previous block in the blockchain is '12345'. This value is a part of the block header for the next block being mined.
Merkle Root Calculation:
Transactions in the block: TX A, TX B, TX C, TX D.
Hashing these transactions in pairs:
TX A and TX B together form HASH X.
TX C and TX D together form HASH Y.
Combining HASH X and HASH Y to form the Merkle Root: HASH Z.
Mining Process with Nonce:
The mining node starts with nonce = 0.
The block header constructed is: '12345HASHZ0'.
Hash (SHA-256) of this header: '0e1bef837d8fda573b44be80971339a4df60888f70425b0af23028a686824556'.
This hash does not meet the Difficulty Target (which, for our example, is a hash starting with '00').
The node then increments the nonce to 1.
New block header: '12345HASHZ1'.
New hash: '1881668681ea58bdc05993655d9714252389e93fb0dec44d5f7987e5169cde57'.
Again, this hash does not meet the Difficulty Target.
The node continues this process, incrementing the nonce each time and recalculating the hash, until it finds a nonce that, when combined with the other parts of the header, produces a hash that meets the Difficulty Target.
To get to nonce, I had to create a program to simulate this mechanism. The goal was to iterate through nonce values until the SHA-256 hash of the block header met the specified difficulty target. In this case, the target was a hash that begins with '00'.
To my fascination, the program had to test 369 (0 is one attempt) different nonce values before it successfully found one that met the criteria. The winning combination turned out to be '12345HASHZ368'. This instance demonstrates the trial-and-error nature of the mining process and the computational work involved in finding the correct nonce.
Verifying the correct nonce is made simple thanks to the SHA256 hashing algorithm. Once a miner finds a nonce that they believe is correct, like '368' in our example, any node in the system can easily check its validity. They just append this nonce to the block data, like "12345HASHZ368", and run it through the SHA256 function. If the output hash meets the difficulty target (starts with 00), then the nonce is verified as correct.
But what if the difficulty target were more stringent? For instance, suppose the requirement was a hash starting with '000'. In this scenario, my program would have to iterate through many more nonce values to find a match. To illustrate, the program would need to test nonce values up to '8976' before finding a hash that meets this more challenging target. Specifically, the input '12345HASHZ8976' would yield the hash '000be772f6de64a461425df53c701935c6a0a6ee0fcf60de6b510446e12546fc', which satisfies the '000' starting condition.
This example underscores how increasing the difficulty target exponentially increases the computational effort required in mining.
In conclusion, the extensive and meticulous process a mining node undergoes to find the correct nonce, as demonstrated in our example, epitomizes what is commonly referred to as 'mining' in the Bitcoin system. This mining is not a physical act, but rather a computational one, where nodes in the network engage in a rigorous and competitive process of trial and error to solve a cryptographic puzzle.
The essence of this puzzle is to discover a nonce value that, when combined with other components of a block header and processed through a hash function (like SHA-256), produces a hash output that meets the network's difficulty target. This target is a critical part of the network's design, ensuring that blocks are generated at a consistent rate, regardless of the overall computational power of the network (we will detail this process shortly).
Mining is thus a cornerstone of the Bitcoin ecosystem. It serves multiple purposes: it secures the network by making it computationally challenging to alter any aspect of the blockchain, it introduces new bitcoins into the system in a controlled and predictable manner, and it incentivizes participants to contribute their computational resources to maintain and operate the network.
The effort expended by nodes in finding the correct nonce is a testament to the decentralized and competitive nature of the Bitcoin network. It underscores the ingenuity of the proof-of-work mechanism, where the combined efforts of numerous miners ensure the integrity, security, and continuity of this groundbreaking digital currency system.
Do you still believe that mining blocks on the Bitcoin network are solving an extremely complex mathematical problem?
We hear this explanation almost every day, but the ASICs (Application-Specific Integrated Circuits) that are hardware used for mining are optimized to perform a specific task.
And what specific task is that?
Trial and error!
A good analogy is those padlocks with sequences of numbers. No mathematical formula exists that, if solved, will open the lock. The only way to open it is to discover the sequence of numbers, and for that, the only possibility is to try and try (0000, 0001, 0002, and so on).
Once discovered, it is easily verified by others, as well as the Bitcoin network.
What the Bitcoin network algorithm does is indicate an output and miners need to test several inputs until they reach that output (marked by the number of zeros at the beginning of the string).
In other words: trial and error!
The more miners on the network, the more attempts are made, the faster the input is discovered, and consequently, the faster the block is mined. For the mining time of each block to remain close to 10 min, every two weeks the algorithm adjusts the difficulty (as if it were adding another number to the lock sequence).
And now maybe a question is hanging over your head: In Bitcoin's decentralized system, any node can contribute computing power to mine blocks, earning block rewards and transaction fees. But what happens if many nodes decide to mine simultaneously? Wouldn't this collective effort lead to finding the correct nonce more quickly and thus creating new blocks in less time than the standard 10 minutes?
This is a pertinent question and touches on a crucial aspect of Bitcoin's design — the difficulty adjustment mechanism. Bitcoin is ingeniously programmed to maintain a consistent pace of block creation, approximately one block every 10 minutes, regardless of the total computational power on the network.
Here's how it works: Bitcoin's protocol includes a mechanism to adjust the mining difficulty. This adjustment occurs every 2,016 blocks. The system evaluates the average time it took to mine the previous 2,016 blocks. If the average mining time was less than 10 minutes per block, the protocol increases the difficulty of mining. Conversely, if the average time was more than 10 minutes, the difficulty decreased.
The difficulty adjustment is primarily achieved by changing the number of leading zeros required in the hash output of the block's header. The more zeros required, the more challenging it is to find a valid hash, and thus, the higher the difficulty. This mechanism ensures that as more computing power joins the network, the difficulty of mining increases, keeping the block creation rate steady.
This difficulty adjustment is a cornerstone of Bitcoin's functionality, allowing it to remain secure and stable in the face of fluctuating mining power. It's a self-balancing system that adapts to the total mining power.
Imagine the Bitcoin network is like a treasure chest locked with a numerical padlock. Each gear on the padlock has numbers ranging from 0 to 9, and the correct combination of these numbers is required to open the lock. In this analogy, the padlock represents the cryptographic challenge of finding the right hash, and the numbers on the gears represent the nonce that miners are trying to guess.
When only a few people (miners) are trying to open the padlock, it takes a considerable amount of time to try every possible combination on a 3-gear padlock (akin to a hash with fewer leading zeros). However, as more people join in the effort, the collective ability to try different combinations increases significantly. Soon, they find that they can open a 3-gear padlock (solve the hash puzzle) in less than 10 minutes.
To maintain the challenge and ensure that the treasure chest (Bitcoin block) doesn't get opened too quickly, the padlock is replaced with one that has an additional gear, making it a 4-gear padlock (equivalent to increasing the number of leading zeros in the hash target). Now, with this more complex lock, even with more people trying, it takes approximately the same amount of time to find the right combination as it did initially with fewer people and a simpler lock.
This ongoing adjustment of the padlock's complexity mirrors Bitcoin's difficulty adjustment mechanism. As more miners join the network and contribute greater hashing power, making it easier to find the correct hash, Bitcoin automatically adjusts the difficulty by essentially adding more 'gears' to the cryptographic 'padlock'. This ensures that the rate of unlocking new blocks (or opening the treasure chest) remains consistent, roughly every 10 minutes, regardless of the number of participants or their combined computational power.
While discussing the difficulty adjustment mechanism in Bitcoin's mining process, it's worth noting a curious aspect rooted in the early code of the Bitcoin Core client. The target recalibration for mining difficulty, intended to occur every 2016 block, actually has a slight quirk due to an off-by-one error in the original programming.
Instead of basing the adjustment on the total time it took to mine the intended 2016 blocks, the algorithm mistakenly calculates this adjustment using the time taken for only 2015 blocks. This slight deviation, while seemingly minor, results in a consistent bias in the recalibration process. The outcome is a subtle but persistent tilt towards increasing the mining difficulty by approximately 0.05%.
The difficulty adjustment mechanism is not influenced by the price of Bitcoin, the number of transactions processed, or the value of these transactions. Instead, it's directly proportional to the collective effort exerted by the mining nodes – essentially, the amount of computational power and, by extension, the electric energy consumed in the mining process.
This means that the amount of hashing power, and consequently the electricity used to secure the Bitcoin network, is entirely independent of transactional activity. Bitcoin's capacity to scale, gain wider adoption, and maintain its security does not inherently require an increase in hashing power from its current levels. The ongoing increase in hashing power primarily reflects market dynamics, with new miners entering the market to compete for mining rewards.
The security of the Bitcoin network hinges on having sufficient hashing power, predominantly under the control of miners motivated by rewards and operating honestly. This adequate level of hashing power is vital for preventing potential takeover attacks and ensuring the network's overall security.
Furthermore, the difficulty of mining in the Bitcoin ecosystem is closely tied to the cost of electricity and the exchange rate of Bitcoin against the currency used to pay for this electricity. High-performance mining systems, operating at the peak of current technological capabilities, convert electricity into hashing computations as efficiently as possible. Therefore, the mining market is significantly influenced by the price of one kilowatt-hour of electricity in terms of Bitcoin. This price determines the profitability of mining operations, thereby influencing the incentives for miners to either enter or exit the mining market.
Once a mining node discovers a nonce that satisfies the Bitcoin network's difficulty target, what happens next?
The node first propagates the new block, along with the winning nonce, across the network. This allows other nodes to quickly and easily verify that the nonce meets the target requirements.
Upon receiving the new block, other nodes in the network perform their validation checks. Each node independently verifies the block against a set of predefined criteria to ensure its validity. As the block passes through the network, it is added to each node's copy of the blockchain, effectively extending the blockchain to a new height.
When mining nodes validate the new block, they stop their efforts to mine a block at the same height and immediately begin working on the next block in the chain. They use the newly discovered block as the "parent" for this next block. This act of building upon the newly discovered block is akin to casting a vote with their mining power, endorsing the new block and the chain it extends (this will be important later when we discuss situations where two blocks are created at the same time).
The next step in Bitcoin's consensus mechanism involves each node on the network independently validating each new block. As the solved block propagates through the network, each node conducts a series of tests to validate it before passing it on. This process ensures that only valid blocks are circulated within the network. It also means that miners who adhere to the network's rules and act honestly have their blocks added to the blockchain, earning them the corresponding rewards. Conversely, miners who attempt to act dishonestly have their blocks rejected, forfeiting the reward and wasting the effort and electricity used to find a Proof-of-Work solution.
Among the criteria used by nodes to validate a new block are several key parameters. These include ensuring that the first transaction in the block is a coinbase transaction (preventing miners can't write themselves a transaction for a thousand bitcoin instead of the correct reward), verifying that the block's size is within acceptable limits (preventing a mining node from including an excessive number of transactions to garner more fees), and confirming that the block header's hash is equal to or less than the current target. These and other criteria form a comprehensive checklist that each block must pass to be accepted into the blockchain, maintaining the network's integrity and trustworthiness.
Once a node in the Bitcoin network validates a new block, its next step is to integrate this block into the existing blockchain. This involves assembling a chain by connecting the newly validated block to the previously established blocks.
The concept of the "main chain" is central to understanding how the Bitcoin network operates. At any given moment, the main chain is defined as the valid chain of blocks with the most cumulative Proof-of-Work associated with it. Under normal conditions, this is also the chain with the greatest number of blocks. However, in cases where two chains are of equal length, the one with more proof of work takes precedence. Alongside the main chain, there are often branches with blocks that are siblings to those on the main chain. These sibling blocks are valid but are not part of the main chain. They are retained for future reference, in case one of these branches gets extended and surpasses the main chain in terms of cumulative work (we will see more when talking about forks).
When a node receives a new block, it endeavors to place this block within the existing blockchain structure. Each block contains a "previous block hash" field, which acts as a reference to its parent block. The node's task is to locate this parent block within the blockchain. In most cases, the parent is found at the "tip" of the main chain, meaning the new block effectively extends the main chain.
As an analogy, let's imagine the Bitcoin blockchain as a growing train made up of a series of connected cars, each representing a block. The train is constantly moving forward, with new cars (blocks) being added to the end of the line.
Each time a new car (block) arrives, the station master (node) checks to ensure it's meant to connect to the very last car of the train (the most recent block in the blockchain). This check is done by examining a unique identifier or code on the new car, which should match the code of the last car on the train. This identifier is akin to the "previous block hash" in a Bitcoin block, linking each new block to its predecessor.
If the codes match and everything checks out, the station master attaches the new car to the end of the train, extending the length of the train (the blockchain). This process is methodical and ensures that each new addition is correctly placed, maintaining the train's (blockchain's) integrity.
Occasionally, there might be situations where two cars arrive almost simultaneously or where a car is meant to attach to an earlier part of the train. These are like the branching scenarios in the blockchain. The station master keeps these cars on a separate track (branch of the blockchain), just in case the main train line needs to be reconfigured or extended differently in the future.
If a valid block is received and no parent is found in the existing chains, that block is considered an "orphan." Orphan blocks are saved in the orphan block pool where they will stay until their parent is received. Once the parent is received and linked into the existing chains, the orphan can be pulled out of the orphan pool and linked to the parent, making it part of a chain. Orphan blocks usually occur when two blocks that were mined within a short time of each other are received in reverse order (child before parent).
https://learnmeabitcoin.com/technical/mining/ 
Andreas M. Antonopoulos - Mastering Bitcoin
Kalle Rosenbaum - Grokking Bitcoin
