But what happens if two mining nodes simultaneously find a nonce that meets the output target and each propagates its block to its neighbors?
This is indeed a possible and natural occurrence in the decentralized structure of the Bitcoin blockchain. Due to the distributed nature of the network, copies of the blockchain across different nodes aren't always perfectly synchronized. Transmission delays and the sheer size of the global network can lead to blocks arriving at different nodes at different times. This can result in nodes having different perspectives of the blockchain's current state.
In such scenarios, where there's a split in the blockchain due to different nodes receiving different blocks at the same time, the phenomenon is known as a "fork." This term aptly describes the situation where the blockchain diverges into two potential paths, much like the prongs of a fork.
Forks in the blockchain occur naturally and are often accidental, stemming from the aforementioned transmission delays. Before a fork, all nodes share the same perspective of the blockchain. A fork happens when there are two valid blocks at the same height, both competing to be added to the blockchain. This typically occurs when two miners solve the Proof-of-Work algorithm almost simultaneously.
Each miner broadcasts their own 'winning' block to their neighbors, starting the propagation across the network. Nodes that receive a valid block add it to their blockchain, extending it by one block. If a node then receives another valid block that extends the same parent block (at the same height), it adds this block to a secondary chain, creating a fork in its version of the blockchain.
Consequently, different nodes might initially 'see' and add different blocks first, leading to two competing versions of the blockchain temporarily existing. 
And how are these forks resolved?
When two valid blocks compete at the same height, creating a fork, the network follows a simple but effective rule to achieve consensus and maintain the blockchain's integrity.
This rule is centered around the concept of the "longest chain," which is often synonymous with the chain that has the most cumulative Proof-of-Work.
The logic here is straightforward: nodes in the network will always consider the longest chain as the valid one. This means that when nodes encounter a fork, they temporarily follow the first block they receive. However, as soon as a longer chain (one with more cumulative work) becomes apparent — typically when a new block is added to one of the forks — the nodes switch to this longer chain.
In practice, this means that when one of the competing forks at the same height grows longer than the other (by having an additional block added to it), the network collectively adopts this chain. The blocks in the shorter fork become 'orphaned' and are discarded in terms of transaction confirmations and rewards. However, the transactions in these orphaned blocks are not lost; they return to the pool of unconfirmed transactions and are eligible for inclusion in future blocks.
The key to resolving forks is the continuous, competitive process of block creation. Miners are constantly working on finding new blocks, and as soon as one fork outpaces the other, the network achieves consensus on the longer, more work-intensive chain. This process ensures that even if forks occur, the Bitcoin blockchain quickly reconverges to a single, consistent state.
Imagine two mining nodes, Node A and Node B, both diligently working to solve the Proof-of-Work algorithm for the next block in the Bitcoin blockchain. Almost simultaneously, each node finds a solution, but for different blocks. Node A propagates a block (let's call it Block Ba) to its neighbors, while Node B propagates another block (Block Bb) to its neighbors. Since both blocks are derived from the same parent block, they are both valid but competing extensions of the blockchain.
In the network, different nodes receive these blocks at different times due to the nature of distributed networks. Some nodes receive Block Ba first and add it to their version of the blockchain. When Block Bb arrives at these nodes, they recognize it as a valid block extending the same parent and attach it as a fork. The same happens in reverse for nodes that received Block Bb first.
Now, the network temporarily has two competing versions of the blockchain: one extended by Block Ba and the other by Block Bb. Miners in the network continue their work, now focusing on creating a new block that will use either Block Ba or Block Bb as its parent, depending on which block they received first.
As mining continues, let's say the miners building on top of Block Ba find a new block, which we'll call Block Baa. This block extends the chain that started with Block Ba. They quickly propagate Block Baa throughout the network. Upon receiving this new block, the entire network recognizes it as a valid extension of the Ba chain, making the Ba-Baa chain longer than the chain ending with Block Bb.
At this point, the network collectively abandons Block Bb in favor of the longer Ba-Baa chain. The transactions that were in Block Bb, but not in Block Ba or Block Baa, are returned to the mempool, awaiting inclusion in future blocks.
The network now reconverges on a single version of the blockchain, with Block Baa as the latest block. All miners across the network update their efforts, beginning to work on new candidate blocks that reference Block Baa as their parent.
Andreas M. Antonopoulos - Mastering Bitcoin
Kalle Rosenbaum - Grokking Bitcoin
https://learnmeabitcoin.com/technical/blockchain/
